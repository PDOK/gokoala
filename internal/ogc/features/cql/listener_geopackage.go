package cql

import (
	"fmt"
	"slices"
	"strings"

	"github.com/PDOK/gokoala/internal/engine/types"
	"github.com/PDOK/gokoala/internal/engine/util"
	"github.com/PDOK/gokoala/internal/ogc/features/cql/parser"
	"github.com/PDOK/gokoala/internal/ogc/features/datasources/geopackage"
)

// GeoPackageListener converts OGC CQL2 Text to GeoPackage-compatible SQL (= SQLite/Spatialite compatible).
type GeoPackageListener struct {
	*CommonListener
}

func NewGeoPackageListener(randomizer util.Randomizer, queryables []string) *GeoPackageListener {
	return &GeoPackageListener{&CommonListener{
		stack:       types.NewStack(),
		namedParams: make(map[string]any),
		randomizer:  randomizer,
		queryables:  queryables,
	}}
}

// GetResult returns the final SQL string generated by the listener.
func (l *GeoPackageListener) GetResult() (string, map[string]any) {
	return l.stack.Peek(), l.namedParams
}

// ExitBooleanExpression Boolean expression
func (l *GeoPackageListener) ExitBooleanExpression(ctx *parser.BooleanExpressionContext) {
	count := len(ctx.AllBooleanTerm())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " OR ") + ")")
	}
}

// ExitBooleanTerm Boolean expression
func (l *GeoPackageListener) ExitBooleanTerm(ctx *parser.BooleanTermContext) {
	count := len(ctx.AllBooleanFactor())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " AND ") + ")")
	}
}

// ExitBooleanFactor Boolean expression
func (l *GeoPackageListener) ExitBooleanFactor(ctx *parser.BooleanFactorContext) {
	if ctx.NOT() != nil {
		expr := l.stack.Pop()
		l.stack.Push("NOT (" + expr + ")")
	}
}

// ExitBinaryComparisonPredicate Comparison expressions (=, <, >, <=, >=, <>)
func (l *GeoPackageListener) ExitBinaryComparisonPredicate(ctx *parser.BinaryComparisonPredicateContext) {
	right := l.stack.Pop()
	left := l.stack.Pop()
	op := ctx.ComparisonOperator().GetText()
	l.stack.Push(fmt.Sprintf("%s %s %s", left, op, right))
}

// ExitPropertyName Handle column names
func (l *GeoPackageListener) ExitPropertyName(ctx *parser.PropertyNameContext) {
	name := ctx.GetText()
	if !l.allowAllQueryables() && !slices.Contains(l.queryables, name) {
		err := fmt.Sprintf("property '%s' cannot be used in CQL filter, is not a queryable property", name)
		l.errorListener.ListenerError(err)
		return
	}

	// add quotes around column names if not already present
	if !strings.HasPrefix(name, "\"") {
		name = "\"" + name + "\""
	}
	l.stack.Push(name)
}

// ExitCharacterLiteral Handle literals
func (l *GeoPackageListener) ExitCharacterLiteral(ctx *parser.CharacterLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateNamedParam(geopackage.NamedParamSymbolSqlx)

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = ctx.GetText()
	}
}

// ExitNumericLiteral Handle literals
func (l *GeoPackageListener) ExitNumericLiteral(ctx *parser.NumericLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateNamedParam(geopackage.NamedParamSymbolSqlx)

		num, err := parseNumber(ctx.GetText())
		if err != nil {
			l.errorListener.ListenerError(err.Error())
			return
		}

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = num
	}
}

// ExitBooleanLiteral Handle literals
func (l *GeoPackageListener) ExitBooleanLiteral(ctx *parser.BooleanLiteralContext) {
	// From GeoPackage spec (https://www.geopackage.org/spec140/index.html):
	// "A boolean value representing true or false. Stored as SQLite INTEGER with value 0 for false or 1 for true."
	if strings.ToUpper(ctx.GetText()) == "TRUE" {
		l.stack.Push("1")
	} else {
		l.stack.Push("0")
	}
}
