package cql

import (
	"fmt"
	"strings"

	"github.com/PDOK/gokoala/internal/engine/types"
	"github.com/PDOK/gokoala/internal/engine/util"
	"github.com/PDOK/gokoala/internal/ogc/features/cql/parser"
	"github.com/PDOK/gokoala/internal/ogc/features/datasources/geopackage"
)

// GeoPackageListener converts OGC CQL2 Text to GeoPackage-compatible SQL (= SQLite/Spatialite compatible).
type GeoPackageListener struct {
	*CommonListener
}

func NewSqliteListener(random util.Randomizer) *GeoPackageListener {
	return &GeoPackageListener{&CommonListener{
		stack:       types.NewStack(),
		namedParams: make(map[string]any),
		randomizer:  random,
	}}
}

// GetSQL returns the final SQL string generated by the listener.
func (l *GeoPackageListener) GetSQL() (string, map[string]any) {
	return l.stack.Peek(), l.namedParams
}

// ExitBooleanExpression Boolean expression
func (l *GeoPackageListener) ExitBooleanExpression(ctx *parser.BooleanExpressionContext) {
	count := len(ctx.AllBooleanTerm())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " OR ") + ")")
	}
}

// ExitBooleanTerm Boolean expression
func (l *GeoPackageListener) ExitBooleanTerm(ctx *parser.BooleanTermContext) {
	count := len(ctx.AllBooleanFactor())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " AND ") + ")")
	}
}

// ExitBooleanFactor Boolean expression
func (l *GeoPackageListener) ExitBooleanFactor(ctx *parser.BooleanFactorContext) {
	if ctx.NOT() != nil {
		expr := l.stack.Pop()
		l.stack.Push("NOT (" + expr + ")")
	}
}

// ExitBinaryComparisonPredicate Comparison expressions (=, <, >, <=, >=, <>)
func (l *GeoPackageListener) ExitBinaryComparisonPredicate(ctx *parser.BinaryComparisonPredicateContext) {
	right := l.stack.Pop()
	left := l.stack.Pop()
	op := ctx.ComparisonOperator().GetText()
	l.stack.Push(fmt.Sprintf("%s %s %s", left, op, right))
}

// ExitPropertyName Field names
func (l *GeoPackageListener) ExitPropertyName(ctx *parser.PropertyNameContext) {
	// TODO: check against whitelist (queryables)
	// TODO: also use named params

	text := ctx.GetText()
	if !strings.HasPrefix(text, "\"") {
		text = "\"" + text + "\""
	}
	l.stack.Push(text)
}

// ExitCharacterLiteral Literals
func (l *GeoPackageListener) ExitCharacterLiteral(ctx *parser.CharacterLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateUniqueNamedParam(geopackage.NamedParamSymbolSqlx)

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = ctx.GetText()
	}
}

// ExitNumericLiteral Literals
func (l *GeoPackageListener) ExitNumericLiteral(ctx *parser.NumericLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateUniqueNamedParam(geopackage.NamedParamSymbolSqlx)

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = ctx.GetText()
	}
}

// ExitBooleanLiteral Literals
func (l *GeoPackageListener) ExitBooleanLiteral(ctx *parser.BooleanLiteralContext) {
	// From GeoPackage spec (https://www.geopackage.org/spec140/index.html):
	// "A boolean value representing true or false. Stored as SQLite INTEGER with value 0 for false or 1 for true."
	if strings.ToUpper(ctx.GetText()) == "TRUE" {
		l.stack.Push("1")
	} else {
		l.stack.Push("0")
	}
}
