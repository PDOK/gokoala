package cql

import (
	"fmt"
	"strings"

	"github.com/PDOK/gokoala/internal/engine/types"
	"github.com/PDOK/gokoala/internal/ogc/features/cql/parser"
)

// SqliteListener converts OGC CQL2 Text to SQLite-compatible SQL.
type SqliteListener struct {
	*parser.BaseCqlParserListener

	stack *types.Stack
}

func NewSqliteListener() *SqliteListener {
	return &SqliteListener{
		stack: types.NewStack(),
	}
}

// GetSQL returns the final SQL string generated by the listener.
func (l *SqliteListener) GetSQL() string {
	return l.stack.Peek()
}

// ExitBooleanExpression Boolean expression
func (l *SqliteListener) ExitBooleanExpression(ctx *parser.BooleanExpressionContext) {
	count := len(ctx.AllBooleanTerm())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " OR ") + ")")
	}
}

// ExitBooleanTerm Boolean expression
func (l *SqliteListener) ExitBooleanTerm(ctx *parser.BooleanTermContext) {
	count := len(ctx.AllBooleanFactor())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " AND ") + ")")
	}
}

// ExitBooleanFactor Boolean expression
func (l *SqliteListener) ExitBooleanFactor(ctx *parser.BooleanFactorContext) {
	if ctx.NOT() != nil {
		expr := l.stack.Pop()
		l.stack.Push("NOT (" + expr + ")")
	}
}

// ExitBinaryComparisonPredicate Comparison expressions (=, <, >, <=, >=, <>)
func (l *SqliteListener) ExitBinaryComparisonPredicate(ctx *parser.BinaryComparisonPredicateContext) {
	right := l.stack.Pop()
	left := l.stack.Pop()
	op := ctx.ComparisonOperator().GetText()
	l.stack.Push(fmt.Sprintf("%s %s %s", left, op, right))
}

// ExitPropertyName Field names
func (l *SqliteListener) ExitPropertyName(ctx *parser.PropertyNameContext) {
	// TODO: check against whitelist (queryables)

	text := ctx.GetText()
	if !strings.HasPrefix(text, "\"") {
		text = "\"" + text + "\""
	}
	l.stack.Push(text)
}

// ExitCharacterLiteral Literals
func (l *SqliteListener) ExitCharacterLiteral(ctx *parser.CharacterLiteralContext) {
	l.stack.Push(ctx.GetText())
}

// ExitNumericLiteral Literals
func (l *SqliteListener) ExitNumericLiteral(ctx *parser.NumericLiteralContext) {
	l.stack.Push(ctx.GetText())
}

// ExitBooleanLiteral Literals
func (l *SqliteListener) ExitBooleanLiteral(ctx *parser.BooleanLiteralContext) {
	// From GeoPackage spec (https://www.geopackage.org/spec140/index.html):
	// "A boolean value representing true or false. Stored as SQLite INTEGER with value 0 for false or 1 for true."
	if strings.ToUpper(ctx.GetText()) == "TRUE" {
		l.stack.Push("1")
	} else {
		l.stack.Push("0")
	}
}
