package cql

import (
	"fmt"
	"strings"

	"github.com/PDOK/gokoala/internal/engine/types"
	"github.com/PDOK/gokoala/internal/engine/util"
	"github.com/PDOK/gokoala/internal/ogc/features/cql/parser"
	"github.com/PDOK/gokoala/internal/ogc/features/datasources/geopackage"
)

const alphabet = "abcdefghijklmnopqrstuvwxyz"

// SqliteListener converts OGC CQL2 Text to SQLite-compatible SQL.
type SqliteListener struct {
	*parser.BaseCqlParserListener

	stack       *types.Stack
	namedParams map[string]any
	randomizer  util.Randomizer
}

func NewSqliteListener(random util.Randomizer) *SqliteListener {
	return &SqliteListener{
		stack:       types.NewStack(),
		namedParams: make(map[string]any),
		randomizer:  random,
	}
}

// GetSQL returns the final SQL string generated by the listener.
func (l *SqliteListener) GetSQL() (string, map[string]any) {
	return l.stack.Peek(), l.namedParams
}

// ExitBooleanExpression Boolean expression
func (l *SqliteListener) ExitBooleanExpression(ctx *parser.BooleanExpressionContext) {
	count := len(ctx.AllBooleanTerm())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " OR ") + ")")
	}
}

// ExitBooleanTerm Boolean expression
func (l *SqliteListener) ExitBooleanTerm(ctx *parser.BooleanTermContext) {
	count := len(ctx.AllBooleanFactor())
	if count > 1 {
		items := l.stack.PopMany(count)
		l.stack.Push("(" + strings.Join(items, " AND ") + ")")
	}
}

// ExitBooleanFactor Boolean expression
func (l *SqliteListener) ExitBooleanFactor(ctx *parser.BooleanFactorContext) {
	if ctx.NOT() != nil {
		expr := l.stack.Pop()
		l.stack.Push("NOT (" + expr + ")")
	}
}

// ExitBinaryComparisonPredicate Comparison expressions (=, <, >, <=, >=, <>)
func (l *SqliteListener) ExitBinaryComparisonPredicate(ctx *parser.BinaryComparisonPredicateContext) {
	right := l.stack.Pop()
	left := l.stack.Pop()
	op := ctx.ComparisonOperator().GetText()
	l.stack.Push(fmt.Sprintf("%s %s %s", left, op, right))
}

// ExitPropertyName Field names
func (l *SqliteListener) ExitPropertyName(ctx *parser.PropertyNameContext) {
	// TODO: check against whitelist (queryables)
	// TODO: also use named params

	text := ctx.GetText()
	if !strings.HasPrefix(text, "\"") {
		text = "\"" + text + "\""
	}
	l.stack.Push(text)
}

// ExitCharacterLiteral Literals
func (l *SqliteListener) ExitCharacterLiteral(ctx *parser.CharacterLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateUniqueNamedParam(geopackage.NamedParamSymbolSqlx)

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = ctx.GetText()
	}
}

// ExitNumericLiteral Literals
func (l *SqliteListener) ExitNumericLiteral(ctx *parser.NumericLiteralContext) {
	if ctx.GetText() != "" {
		withoutSymbol, withSymbol := l.generateUniqueNamedParam(geopackage.NamedParamSymbolSqlx)

		l.stack.Push(withSymbol)
		l.namedParams[withoutSymbol] = ctx.GetText()
	}
}

// ExitBooleanLiteral Literals
func (l *SqliteListener) ExitBooleanLiteral(ctx *parser.BooleanLiteralContext) {
	// From GeoPackage spec (https://www.geopackage.org/spec140/index.html):
	// "A boolean value representing true or false. Stored as SQLite INTEGER with value 0 for false or 1 for true."
	if strings.ToUpper(ctx.GetText()) == "TRUE" {
		l.stack.Push("1")
	} else {
		l.stack.Push("0")
	}
}

func (l *SqliteListener) generateUniqueNamedParam(symbol string) string {
RETRY:
	chars := make([]byte, 4)
	for i := range chars {
		chars[i] = alphabet[l.randomizer.IntN(len(alphabet))]
	}

	result := fmt.Sprintf("%scql_%s", symbol, string(chars)) // for example "@cql_xmzq" or ":cql_abri"
	_, exists := l.namedParams[result]
	if exists {
		goto RETRY
	}
	return result
}
