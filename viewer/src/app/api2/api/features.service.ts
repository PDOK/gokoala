/**
 * PDOK Location API
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent, HttpParameterCodec, HttpContext } from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

// @ts-ignore
import { Exception } from '../model/exception'
// @ts-ignore
import { FeatureCollectionGeoJSON } from '../model/featureCollectionGeoJSON'
// @ts-ignore
import { FeatureCollectionJSONFG } from '../model/featureCollectionJSONFG'
// @ts-ignore
import { SearchFunctioneelGebiedParameter } from '../model/searchFunctioneelGebiedParameter'
// @ts-ignore
import { SearchGeografischGebiedParameter } from '../model/searchGeografischGebiedParameter'
// @ts-ignore
import { SearchLigplaatsParameter } from '../model/searchLigplaatsParameter'
// @ts-ignore
import { SearchStandplaatsParameter } from '../model/searchStandplaatsParameter'
// @ts-ignore
import { SearchVerblijfsobjectParameter } from '../model/searchVerblijfsobjectParameter'
// @ts-ignore
import { SearchWoonplaatsParameter } from '../model/searchWoonplaatsParameter'

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable({
  providedIn: 'root',
})
export class FeaturesService {
  protected basePath = 'https://api.pdok.nl/bzk/location-api/autocomplete/v1-preprod'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()
  public encoder: HttpParameterCodec

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration
    }
    if (typeof this.configuration.basePath !== 'string') {
      const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined
      if (firstBasePath != undefined) {
        basePath = firstBasePath
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath
      }
      this.configuration.basePath = basePath
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
  }

  // @ts-ignore
  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value)
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key)
    }
    return httpParams
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        ;(value as any[]).forEach(elem => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)))
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10))
        } else {
          throw Error('key may not be null if value is Date')
        }
      } else {
        Object.keys(value).forEach(k => (httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k)))
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value)
    } else {
      throw Error('key may not be null if value is not object or array')
    }
    return httpParams
  }

  /**
   * search features in one or more collections across datasets.
   * This endpoint allows one to implement autocomplete functionality for location search. The &#x60;q&#x60; parameter accepts a partial location name and will return all matching locations up to the specified &#x60;limit&#x60;. The list of search results are offered as features (in GeoJSON, JSON-FG) but contain only minimal information; like a feature ID, highlighted text and a bounding box. When you want to get the full feature you must follow the included link (&#x60;href&#x60;) in the search result. This allows one to retrieve all properties of the feature and the full geometry from the corresponding OGC API.
   * @param q The search term(s)
   * @param functioneelGebied When provided the functioneel_gebied collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the functioneel_gebied collection, for example &#x60;q&#x3D;foo&amp;functioneel_gebied[version]&#x3D;1&amp;functioneel_gebied[relevance]&#x3D;0.5&#x60;
   * @param geografischGebied When provided the geografisch_gebied collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the geografisch_gebied collection, for example &#x60;q&#x3D;foo&amp;geografisch_gebied[version]&#x3D;1&amp;geografisch_gebied[relevance]&#x3D;0.5&#x60;
   * @param ligplaats When provided the ligplaats collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the ligplaats collection, for example &#x60;q&#x3D;foo&amp;ligplaats[version]&#x3D;1&amp;ligplaats[relevance]&#x3D;0.5&#x60;
   * @param standplaats When provided the standplaats collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the standplaats collection, for example &#x60;q&#x3D;foo&amp;standplaats[version]&#x3D;1&amp;standplaats[relevance]&#x3D;0.5&#x60;
   * @param verblijfsobject When provided the verblijfsobject collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the verblijfsobject collection, for example &#x60;q&#x3D;foo&amp;verblijfsobject[version]&#x3D;1&amp;verblijfsobject[relevance]&#x3D;0.5&#x60;
   * @param woonplaats When provided the woonplaats collection is included in the search. This parameter should be provided as a [deep object](https://swagger.io/docs/specification/v3_0/serialization/#query-parameters) containing the version and relevance of the woonplaats collection, for example &#x60;q&#x3D;foo&amp;woonplaats[version]&#x3D;1&amp;woonplaats[relevance]&#x3D;0.5&#x60;
   * @param limit The optional limit parameter limits the number of items that are presented in the response document.  Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted.  Minimum &#x3D; 1. Maximum &#x3D; 50. Default &#x3D; 10.
   * @param crs The coordinate reference system of the geometries in the response. Default is WGS84 longitude/latitude
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public search(
    q: string,
    functioneelGebied?: SearchFunctioneelGebiedParameter,
    geografischGebied?: SearchGeografischGebiedParameter,
    ligplaats?: SearchLigplaatsParameter,
    standplaats?: SearchStandplaatsParameter,
    verblijfsobject?: SearchVerblijfsobjectParameter,
    woonplaats?: SearchWoonplaatsParameter,
    limit?: number,
    crs?: 'http://www.opengis.net/def/crs/OGC/1.3/CRS84' | 'http://www.opengis.net/def/crs/EPSG/0/28992',
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/geo+json' | 'application/vnd.ogc.fg+json' | 'text/html' | 'application/problem+json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<FeatureCollectionGeoJSON>
  public search(
    q: string,
    functioneelGebied?: SearchFunctioneelGebiedParameter,
    geografischGebied?: SearchGeografischGebiedParameter,
    ligplaats?: SearchLigplaatsParameter,
    standplaats?: SearchStandplaatsParameter,
    verblijfsobject?: SearchVerblijfsobjectParameter,
    woonplaats?: SearchWoonplaatsParameter,
    limit?: number,
    crs?: 'http://www.opengis.net/def/crs/OGC/1.3/CRS84' | 'http://www.opengis.net/def/crs/EPSG/0/28992',
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/geo+json' | 'application/vnd.ogc.fg+json' | 'text/html' | 'application/problem+json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<FeatureCollectionGeoJSON>>
  public search(
    q: string,
    functioneelGebied?: SearchFunctioneelGebiedParameter,
    geografischGebied?: SearchGeografischGebiedParameter,
    ligplaats?: SearchLigplaatsParameter,
    standplaats?: SearchStandplaatsParameter,
    verblijfsobject?: SearchVerblijfsobjectParameter,
    woonplaats?: SearchWoonplaatsParameter,
    limit?: number,
    crs?: 'http://www.opengis.net/def/crs/OGC/1.3/CRS84' | 'http://www.opengis.net/def/crs/EPSG/0/28992',
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/geo+json' | 'application/vnd.ogc.fg+json' | 'text/html' | 'application/problem+json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<FeatureCollectionGeoJSON>>
  public search(
    q: string,
    functioneelGebied?: SearchFunctioneelGebiedParameter,
    geografischGebied?: SearchGeografischGebiedParameter,
    ligplaats?: SearchLigplaatsParameter,
    standplaats?: SearchStandplaatsParameter,
    verblijfsobject?: SearchVerblijfsobjectParameter,
    woonplaats?: SearchWoonplaatsParameter,
    limit?: number,
    crs?: 'http://www.opengis.net/def/crs/OGC/1.3/CRS84' | 'http://www.opengis.net/def/crs/EPSG/0/28992',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/geo+json' | 'application/vnd.ogc.fg+json' | 'text/html' | 'application/problem+json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (q === null || q === undefined) {
      throw new Error('Required parameter q was null or undefined when calling search.')
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (q !== undefined && q !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>q, 'q')
    }
    if (functioneelGebied !== undefined && functioneelGebied !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>functioneelGebied, 'functioneel_gebied')
    }
    if (geografischGebied !== undefined && geografischGebied !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>geografischGebied, 'geografisch_gebied')
    }
    if (ligplaats !== undefined && ligplaats !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>ligplaats, 'ligplaats')
    }
    if (standplaats !== undefined && standplaats !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>standplaats, 'standplaats')
    }
    if (verblijfsobject !== undefined && verblijfsobject !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>verblijfsobject, 'verblijfsobject')
    }
    if (woonplaats !== undefined && woonplaats !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>woonplaats, 'woonplaats')
    }
    if (limit !== undefined && limit !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>limit, 'limit')
    }
    if (crs !== undefined && crs !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>crs, 'crs')
    }

    let localVarHeaders = this.defaultHeaders

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/geo+json', 'application/vnd.ogc.fg+json', 'text/html', 'application/problem+json']
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected)
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext()
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/search`
    return this.httpClient.request<FeatureCollectionGeoJSON>('get', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    })
  }
}
